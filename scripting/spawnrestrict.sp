/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools_functions>

new Handle:g_cEnable;
new Handle:g_cExtend;
new Handle:g_Weapons;
new Handle:g_Buildings;

new bool:g_bEnable;
new g_iExtend;

new bool:isRestricted[MAXPLAYERS+1];
new String:restrictedWeapon[MAXPLAYERS+1][64];

public Plugin:myinfo = 
{
	name = "Spawn Restict",
	author = "Panzer",
	description = "Restrict certain weapons and buildings in spawns",
	version = "1.0",
	url = "http://www.sourcemod.net/"
}

public OnPluginStart()
{
	// Admin commands
	RegAdminCmd("sr_weapon", Command_Weapon, ADMFLAG_KICK, "sr_weapon <weapon> (rocketlauncher, grenadelauncher, stickylauncher, sniperrifle)");
	RegAdminCmd("sr_weapon_clear", Command_WeaponClear, ADMFLAG_KICK, "sr_weapon_clear");
	RegAdminCmd("sr_building", Command_Building, ADMFLAG_KICK, "sr_building <building> (sentry, dispenser, teleporter)");
	RegAdminCmd("sr_building_clear", Command_BuildingClear, ADMFLAG_KICK, "sr_building_clear");
	RegAdminCmd("sr_clear", Command_Clear, ADMFLAG_KICK, "sr_clear");

	// ConVars
	g_cEnable = CreateConVar("sr_enable", "1", "Enable/Disable Spawn Restrict - 1 = Enable, 0 = Disable");
	g_cExtend = CreateConVar("sr_extend", "256", "Extend The Spawn Triggers By The Specified Amount");

	// Hooks
	HookConVarChange(g_cEnable, ConVarChanged_SpawnRestrict);
	HookConVarChange(g_cExtend, ConVarChanged_SpawnRestrict);
	
	HookEvent("player_spawn", Event_PlayerSpawn);
	
	// Create dynamic arrays
	g_Weapons = CreateArray(32);
	g_Buildings = CreateArray(32);
}

public OnPluginEnd()
{
	// Unrestrict players and clear restriction lists
	for (new client = 1; client <= MaxClients; client++)
		if (isRestricted[client])
			SetEntPropFloat(client, Prop_Data, "m_flNextAttack", 0.0);
	ClearArray(g_Weapons);
	ClearArray(g_Buildings);
}

public OnMapEnd()
{
	ClearArray(g_Weapons);
	ClearArray(g_Buildings);
}

public ConVarChanged_SpawnRestrict(Handle:convar, const String:oldValue[], const String:newValue[])
{
	if (convar == g_cEnable) 
		g_bEnable = GetConVarBool(g_cEnable);
	if (convar == g_cExtend) 
		g_iExtend = GetConVarInt(g_cExtend);
}

public OnConfigsExecuted()
{
	g_bEnable	 = GetConVarBool(g_cEnable);
	g_iExtend = GetConVarInt(g_cExtend);
}

public Action:Command_Weapon(client, args)
{
	decl String:arg[64]
	GetCmdArgString(arg, sizeof(arg))

	if (args != 1)
		ReplyToCommand(client, "[Spawn Restrict] Usage: sr_weapon <weapon> (rocketlauncher, grenadelauncher, stickylauncher, sniperrifle)");
	else
	{
		if (StrEqual(arg, "rocket") || StrEqual(arg, "rocketlauncher"))
			arg = "tf_weapon_rocketlauncher";
		else if (StrEqual(arg, "grenade") || StrEqual(arg, "grenadelauncher"))
			arg = "tf_weapon_grenadelauncher";
		else if (StrEqual(arg, "sticky") || StrEqual(arg, "stickylauncher"))
			arg = "tf_weapon_pipebomblauncher";
		else if (StrEqual(arg, "sniper") || StrEqual(arg, "sniperrifle"))
			arg = "tf_weapon_sniperrifle";
		PushArrayString(g_Weapons, arg);
		ReplyToCommand(client, "[Spawn Restrict] %s has been restricted", arg);
	}
}

public Action:Command_WeaponClear(client, args)
{
	// Unrestrict players and clear restriction lists
	for (new i = 1; i <= MaxClients; i++)
		if (isRestricted[i])
			SetEntPropFloat(i, Prop_Data, "m_flNextAttack", 0.0);
	ClearArray(g_Weapons);
	ReplyToCommand(client, "[Spawn Restrict] Restricted weapons list has been cleared");
}

public Action:Command_Building(client, args)
{
	decl String:arg[64]
	GetCmdArgString(arg, sizeof(arg))

	if (args != 1)
		ReplyToCommand(client, "[Spawn Restrict] Usage: sr_building <building> (sentry, dispenser, teleporter)");
	else
	{
		if (StrEqual(arg, "sentry"))
			arg = "obj_sentrygun";
		else if (StrEqual(arg, "dispenser"))
			arg = "obj_dispenser";
		else if (StrEqual(arg, "tele") || StrEqual(arg, "teleporter"))
			arg = "obj_teleporter";
		PushArrayString(g_Buildings, arg);
		ReplyToCommand(client, "[Spawn Restrict] %s has been restricted", arg);
	}
}

public Action:Command_BuildingClear(client, args)
{
	ClearArray(g_Weapons);
	ReplyToCommand(client, "[Spawn Restrict] Restricted buildings list has been cleared");
}

public Action:Command_Clear(client, args)
{
	// Unrestrict players and clear restriction lists
	for (new i = 1; i <= MaxClients; i++)
		if (isRestricted[i])
			SetEntPropFloat(i, Prop_Data, "m_flNextAttack", 0.0);
	ClearArray(g_Weapons);
	ClearArray(g_Buildings);
	ReplyToCommand(client, "[Spawn Restrict] Restricted weapons list and restricted buildings list have been cleared");
}

public Event_PlayerSpawn(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	isRestricted[client] = false;
}

public OnGameFrame()
{
	// Restrict weapons and buildings that are in the restriction list
	if (!g_bEnable) return;
	for (new weapon = 0; weapon < GetArraySize(g_Weapons); weapon++)
	{
		decl String:weaponName[64];
		GetArrayString(g_Weapons, weapon, weaponName, sizeof(weaponName));
		WeaponRestrict(weaponName);
	}
	for (new building = 0; building < GetArraySize(g_Buildings); building++)
	{
		decl String:buildingName[64];
		GetArrayString(g_Buildings, building, buildingName, sizeof(buildingName));
		BuildingRestrict(buildingName);
	}
}

public WeaponRestrict(const String:weapon[])
{
	new bool:inSpawn[MAXPLAYERS+1];
	// Set client to unrestricted when they change weapons (this allows the warning message to show different weapons being restricted)
	for (new client = 1; client <= MaxClients; client++)
	{
		if (isRestricted[client] && IsValidEntity(client) && IsClientInGame(client) && IsPlayerAlive(client))
		{
		inSpawn[client] = false;
		decl String:clientWeapon[64];
		GetClientWeapon(client, clientWeapon, sizeof(clientWeapon));
		if (!StrEqual(restrictedWeapon[client], clientWeapon))
			isRestricted[client] = false;
		}
	}
	// Find all spawn rooms
	new spawnRoom = -1;
	while ((spawnRoom = FindEntityByClassname(spawnRoom, "func_respawnroom")) != -1)
	{	
		// Find end points of the spawn room trigger
		new Float:minVec[3], Float:maxVec[3];
		GetEntPropVector(spawnRoom, Prop_Send, "m_vecMins", minVec);
		GetEntPropVector(spawnRoom, Prop_Send, "m_vecMaxs", maxVec);
		
		// Extend the spawn room's end points
		minVec[0] -= g_iExtend;
		maxVec[0] += g_iExtend;
		minVec[1] -= g_iExtend;
		maxVec[1] += g_iExtend;
		
		// Check if the client is between the spawn room trigger end points
		for (new client = 1; client <= MaxClients; client++)
		{
			if (!IsValidEntity(client) || !IsClientInGame(client) || !IsPlayerAlive(client)) continue;
			new Float:pos[3];
			GetClientAbsOrigin(client, pos);
			// Restrict the client's weapon in spawn
			if (pos[0] >= minVec[0] && pos[0] <= maxVec[0] &&
				pos[1] >= minVec[1] && pos[1] <= maxVec[1] &&
				pos[2] >= minVec[2] && pos[2] <= maxVec[2])
			{
				inSpawn[client] = true;
				decl String:clientWeapon[64];
				GetClientWeapon(client, clientWeapon, sizeof(clientWeapon));
				if (StrEqual(weapon, clientWeapon))
				{
					if (!isRestricted[client])
					{
						PrintToChat(client, "\x04[Spawn Restrict]\x01 \x03%s\x01 is restricted in spawn!", clientWeapon);
						isRestricted[client] = true;
						restrictedWeapon[client] = clientWeapon;
					}
					SetEntPropFloat(client, Prop_Data, "m_flNextAttack", 9999999999.0);
					return;
				}
			}
		}
	}
	// Unrestrict client when they leave spawn
	for (new client = 1; client <= MaxClients; client++)
	{
		if (!IsValidEntity(client) || !IsClientInGame(client) || !IsPlayerAlive(client)) continue;
		if (!inSpawn[client] && isRestricted[client])
		{
				SetEntPropFloat(client, Prop_Data, "m_flNextAttack", 0.0);
				isRestricted[client] = false;
				decl String:clientWeapon[64];
				GetClientWeapon(client, clientWeapon, sizeof(clientWeapon));
				PrintToChat(client, "\x04[Spawn Restrict]\x01 Your weapons have been unrestricted!", clientWeapon);
		}
	}
}

public BuildingRestrict(const String:building[])
{
	// Find all spawn rooms
	new spawnRoom = -1;
	while ((spawnRoom = FindEntityByClassname(spawnRoom, "func_respawnroom")) != -1)
	{	
		// Find end points of the spawn room trigger
		new Float:minVec[3], Float:maxVec[3];
		GetEntPropVector(spawnRoom, Prop_Send, "m_vecMins", minVec);
		GetEntPropVector(spawnRoom, Prop_Send, "m_vecMaxs", maxVec);
		
		// Extend the spawn room's end points
		minVec[0] -= g_iExtend;
		maxVec[0] += g_iExtend;
		minVec[1] -= g_iExtend;
		maxVec[1] += g_iExtend;
		
		// Check if the building is between the spawn room trigger end points
		new ent = -1;
		while ((ent = FindEntityByClassname(ent, building)) != -1)
		{
			if (!IsValidEntity(ent)) continue;
			new Float:pos[3];
			GetEntPropVector(ent, Prop_Data, "m_vecOrigin", pos);
			// Remove the client's building in spawn
			if (pos[0] >= minVec[0] && pos[0] <= maxVec[0] &&
				pos[1] >= minVec[1] && pos[1] <= maxVec[1] &&
				pos[2] >= minVec[2] && pos[2] <= maxVec[2])
			{
				//Send message to player
				PrintToChat(GetEntPropEnt(ent, Prop_Send, "m_hBuilder"), "\x04[Spawn Restrict]\x01 \x03%s\x01 is restricted in spawn!", building);

				// Remove the building
				RemoveEdict(ent);
				return;
			}
		}
	}
}